<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js VR Teleport</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js",
                "three/examples/jsm/loaders/GLTFLoader": "https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/loaders/GLTFLoader.js",
                "three/examples/jsm/webxr/VRButton": "https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/webxr/VRButton.js",
                "three/examples/jsm/webxr/XRControllerModelFactory": "https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/webxr/XRControllerModelFactory.js"
            }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; }
    </style>
</head>
<body>
    <script type="module">
        import * as THREE from "three";
        import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";
        import { VRButton } from "three/examples/jsm/webxr/VRButton";
        import { XRControllerModelFactory } from "three/examples/jsm/webxr/XRControllerModelFactory";

        const scene = new THREE.Scene();
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.6, 3);
        
        const cameraRig = new THREE.Group();
        cameraRig.add(camera);
        scene.add(cameraRig);

        let floorMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(10, 10),
            new THREE.MeshStandardMaterial({ color: 0x555555 })
        );
        floorMesh.rotation.x = -Math.PI / 2;
        floorMesh.receiveShadow = true;
        scene.add(floorMesh);

        const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
        scene.add(light);

        // Teleportation Marker con sfumatura
        const teleportMaterial = new THREE.ShaderMaterial({
            uniforms: { color: { value: new THREE.Color(0x00ffff) } },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec2 vUv;
                uniform vec3 color;
                void main() {
                    float alpha = smoothstep(1.0, 0.3, vUv.y);
                    gl_FragColor = vec4(color, alpha);
                }
            `,
            transparent: true
        });

        let teleportationMarker = new THREE.Mesh(
            new THREE.RingGeometry(0.1, 0.5, 32),
            teleportMaterial
        );
        teleportationMarker.rotation.x = -Math.PI / 2;
        teleportationMarker.visible = false;
        scene.add(teleportationMarker);

        // Fascio del teletrasporto curvo
        let debugLine = new THREE.Line(
            new THREE.BufferGeometry(),
            new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 3 })
        );
        scene.add(debugLine);
        debugLine.visible = false;

        let teleportationTarget = null;
        let isTriggerPressed = false;

        function createTeleportArc(controller) {
            const numPoints = 20;
            const points = [];
            const start = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);
            const direction = new THREE.Vector3(0, 0, -1).applyMatrix4(controller.matrixWorld);
            const velocity = direction.multiplyScalar(2.5);

            for (let i = 0; i < numPoints; i++) {
                const t = i / (numPoints - 1);
                const point = new THREE.Vector3(
                    start.x + velocity.x * t,
                    start.y + velocity.y * t - 4.9 * t * t,
                    start.z + velocity.z * t
                );
                points.push(point);
            }

            const curve = new THREE.CatmullRomCurve3(points);
            const geometry = new THREE.BufferGeometry().setFromPoints(curve.getPoints(numPoints));

            debugLine.geometry.dispose();
            debugLine.geometry = geometry;
            debugLine.visible = true;
        }

        function getIntersections(controller) {
            const tempMatrix = new THREE.Matrix4().extractRotation(controller.matrixWorld);
            const ray = new THREE.Raycaster();
            ray.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            ray.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

            return ray.intersectObject(floorMesh, true);
        }

        function updateTeleportationTarget(controller) {
            if (!isTriggerPressed) return;

            const intersections = getIntersections(controller);
            if (intersections.length > 0) {
                teleportationTarget = intersections[0].point;
                teleportationMarker.position.copy(teleportationTarget);
                teleportationMarker.visible = true;
                createTeleportArc(controller);
            } else {
                teleportationMarker.visible = false;
                debugLine.visible = false;
            }

            requestAnimationFrame(() => updateTeleportationTarget(controller));
        }

        function onSelectStart(event) {
            isTriggerPressed = true;
            updateTeleportationTarget(event.target);
        }

        function onSelectEnd() {
            isTriggerPressed = false;
            if (teleportationTarget) {
                cameraRig.position.set(teleportationTarget.x, cameraRig.position.y, teleportationTarget.z);
            }
            teleportationMarker.visible = false;
            debugLine.visible = false;
        }

        const controllerModelFactory = new XRControllerModelFactory();
        let controller1, controller2;

        function setupXRControllers() {
            controller1 = renderer.xr.getController(0);
            if (controller1) {
                controller1.addEventListener("selectstart", onSelectStart);
                controller1.addEventListener("selectend", onSelectEnd);
                cameraRig.add(controller1);

                const grip1 = renderer.xr.getControllerGrip(0);
                grip1.add(controllerModelFactory.createControllerModel(grip1));
                cameraRig.add(grip1);
            }

            controller2 = renderer.xr.getController(1);
            if (controller2) {
                controller2.addEventListener("selectstart", onSelectStart);
                controller2.addEventListener("selectend", onSelectEnd);
                cameraRig.add(controller2);

                const grip2 = renderer.xr.getControllerGrip(1);
                grip2.add(controllerModelFactory.createControllerModel(grip2));
                cameraRig.add(grip2);
            }
        }

        renderer.xr.addEventListener("sessionstart", setupXRControllers);

        function animate() {
            renderer.setAnimationLoop(() => {
                renderer.render(scene, camera);
            });
        }

        animate();
    </script>
</body>
</html>
